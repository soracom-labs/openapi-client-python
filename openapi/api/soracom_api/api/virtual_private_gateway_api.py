"""
    SORACOM API

    SORACOM API v1  # noqa: E501

    The version of the OpenAPI document: VERSION_PLACEHOLDER
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from soracom_api.api_client import ApiClient, Endpoint as _Endpoint
from soracom_api.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from soracom_api.model.attribute_update import AttributeUpdate
from soracom_api.model.create_virtual_private_gateway_request import CreateVirtualPrivateGatewayRequest
from soracom_api.model.create_vpc_peering_connection_request import CreateVpcPeeringConnectionRequest
from soracom_api.model.gate_peer import GatePeer
from soracom_api.model.ip_address_map_entry import IpAddressMapEntry
from soracom_api.model.junction_inspection_configuration import JunctionInspectionConfiguration
from soracom_api.model.junction_mirroring_peer import JunctionMirroringPeer
from soracom_api.model.junction_redirection_configuration import JunctionRedirectionConfiguration
from soracom_api.model.open_gate_request import OpenGateRequest
from soracom_api.model.packet_capture_session import PacketCaptureSession
from soracom_api.model.packet_capture_session_request import PacketCaptureSessionRequest
from soracom_api.model.put_ip_address_map_entry_request import PutIpAddressMapEntryRequest
from soracom_api.model.register_gate_peer_request import RegisterGatePeerRequest
from soracom_api.model.routing_filter_entry import RoutingFilterEntry
from soracom_api.model.virtual_private_gateway import VirtualPrivateGateway


class VirtualPrivateGatewayApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.close_gate_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/gate/close',
                'operation_id': 'close_gate',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.create_mirroring_peer_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/junction/mirroring/peers',
                'operation_id': 'create_mirroring_peer',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'junction_mirroring_peer',
                ],
                'required': [
                    'vpg_id',
                    'junction_mirroring_peer',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'junction_mirroring_peer':
                        (JunctionMirroringPeer,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'junction_mirroring_peer': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_packet_capture_session_endpoint = _Endpoint(
            settings={
                'response_type': (PacketCaptureSession,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/packet_capture_sessions',
                'operation_id': 'create_packet_capture_session',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'packet_capture_session_request',
                ],
                'required': [
                    'vpg_id',
                    'packet_capture_session_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'packet_capture_session_request':
                        (PacketCaptureSessionRequest,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'packet_capture_session_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_virtual_private_gateway_endpoint = _Endpoint(
            settings={
                'response_type': (VirtualPrivateGateway,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways',
                'operation_id': 'create_virtual_private_gateway',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'create_virtual_private_gateway_request',
                ],
                'required': [
                    'create_virtual_private_gateway_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'create_virtual_private_gateway_request':
                        (CreateVirtualPrivateGatewayRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'create_virtual_private_gateway_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_vpc_peering_connection_endpoint = _Endpoint(
            settings={
                'response_type': (CreateVpcPeeringConnectionRequest,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/vpc_peering_connections',
                'operation_id': 'create_vpc_peering_connection',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'create_vpc_peering_connection_request',
                ],
                'required': [
                    'vpg_id',
                    'create_vpc_peering_connection_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'create_vpc_peering_connection_request':
                        (CreateVpcPeeringConnectionRequest,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'create_vpc_peering_connection_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_mirroring_peer_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/junction/mirroring/peers/{ipaddr}',
                'operation_id': 'delete_mirroring_peer',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'ipaddr',
                ],
                'required': [
                    'vpg_id',
                    'ipaddr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'ipaddr':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'ipaddr': 'ipaddr',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'ipaddr': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_packet_capture_session_endpoint = _Endpoint(
            settings={
                'response_type': (PacketCaptureSession,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}',
                'operation_id': 'delete_packet_capture_session',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'session_id',
                ],
                'required': [
                    'vpg_id',
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'session_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'session_id': 'session_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'session_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_virtual_private_gateway_ip_address_map_entry_endpoint = _Endpoint(
            settings={
                'response_type': (IpAddressMapEntry,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/ip_address_map/{key}',
                'operation_id': 'delete_virtual_private_gateway_ip_address_map_entry',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'key',
                ],
                'required': [
                    'vpg_id',
                    'key',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'key':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'key': 'key',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'key': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_vpc_peering_connection_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/vpc_peering_connections/{pcx_id}',
                'operation_id': 'delete_vpc_peering_connection',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'pcx_id',
                ],
                'required': [
                    'vpg_id',
                    'pcx_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'pcx_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'pcx_id': 'pcx_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'pcx_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_packet_capture_session_endpoint = _Endpoint(
            settings={
                'response_type': (PacketCaptureSession,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}',
                'operation_id': 'get_packet_capture_session',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'session_id',
                ],
                'required': [
                    'vpg_id',
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'session_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'session_id': 'session_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'session_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_virtual_private_gateway_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}',
                'operation_id': 'get_virtual_private_gateway',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_gate_peers_endpoint = _Endpoint(
            settings={
                'response_type': ([GatePeer],),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/gate/peers',
                'operation_id': 'list_gate_peers',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_packet_capture_sessions_endpoint = _Endpoint(
            settings={
                'response_type': ([PacketCaptureSession],),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/packet_capture_sessions',
                'operation_id': 'list_packet_capture_sessions',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'last_evaluated_key',
                    'limit',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'last_evaluated_key':
                        (str,),
                    'limit':
                        (int,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'last_evaluated_key': 'last_evaluated_key',
                    'limit': 'limit',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'last_evaluated_key': 'query',
                    'limit': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_virtual_private_gateway_ip_address_map_entries_endpoint = _Endpoint(
            settings={
                'response_type': ([IpAddressMapEntry],),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/ip_address_map',
                'operation_id': 'list_virtual_private_gateway_ip_address_map_entries',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_virtual_private_gateways_endpoint = _Endpoint(
            settings={
                'response_type': ([VirtualPrivateGateway],),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways',
                'operation_id': 'list_virtual_private_gateways',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'tag_name',
                    'tag_value',
                    'tag_value_match_mode',
                    'limit',
                    'last_evaluated_key',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'tag_value_match_mode',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('tag_value_match_mode',): {

                        "EXACT": "exact",
                        "PREFIX": "prefix"
                    },
                },
                'openapi_types': {
                    'tag_name':
                        (str,),
                    'tag_value':
                        (str,),
                    'tag_value_match_mode':
                        (str,),
                    'limit':
                        (int,),
                    'last_evaluated_key':
                        (str,),
                },
                'attribute_map': {
                    'tag_name': 'tag_name',
                    'tag_value': 'tag_value',
                    'tag_value_match_mode': 'tag_value_match_mode',
                    'limit': 'limit',
                    'last_evaluated_key': 'last_evaluated_key',
                },
                'location_map': {
                    'tag_name': 'query',
                    'tag_value': 'query',
                    'tag_value_match_mode': 'query',
                    'limit': 'query',
                    'last_evaluated_key': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.open_gate_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/gate/open',
                'operation_id': 'open_gate',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'open_gate_request',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'open_gate_request':
                        (OpenGateRequest,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'open_gate_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.put_virtual_private_gateway_ip_address_map_entry_endpoint = _Endpoint(
            settings={
                'response_type': (IpAddressMapEntry,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/ip_address_map',
                'operation_id': 'put_virtual_private_gateway_ip_address_map_entry',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'put_ip_address_map_entry_request',
                ],
                'required': [
                    'vpg_id',
                    'put_ip_address_map_entry_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'put_ip_address_map_entry_request':
                        (PutIpAddressMapEntryRequest,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'put_ip_address_map_entry_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.register_gate_peer_endpoint = _Endpoint(
            settings={
                'response_type': (GatePeer,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/gate/peers',
                'operation_id': 'register_gate_peer',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'register_gate_peer_request',
                ],
                'required': [
                    'vpg_id',
                    'register_gate_peer_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'register_gate_peer_request':
                        (RegisterGatePeerRequest,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'register_gate_peer_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.set_inspection_configuration_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/junction/set_inspection',
                'operation_id': 'set_inspection_configuration',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'junction_inspection_configuration',
                ],
                'required': [
                    'vpg_id',
                    'junction_inspection_configuration',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'junction_inspection_configuration':
                        (JunctionInspectionConfiguration,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'junction_inspection_configuration': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.set_redirection_configuration_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/junction/set_redirection',
                'operation_id': 'set_redirection_configuration',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'junction_redirection_configuration',
                ],
                'required': [
                    'vpg_id',
                    'junction_redirection_configuration',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'junction_redirection_configuration':
                        (JunctionRedirectionConfiguration,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'junction_redirection_configuration': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.set_routing_filter_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/set_routing_filter',
                'operation_id': 'set_routing_filter',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'routing_filter_entry',
                ],
                'required': [
                    'vpg_id',
                    'routing_filter_entry',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'routing_filter_entry':
                        ([RoutingFilterEntry],),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'routing_filter_entry': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.stop_packet_capture_session_endpoint = _Endpoint(
            settings={
                'response_type': (PacketCaptureSession,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}/stop',
                'operation_id': 'stop_packet_capture_session',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'session_id',
                ],
                'required': [
                    'vpg_id',
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'session_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'session_id': 'session_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'session_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.terminate_virtual_private_gateway_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/terminate',
                'operation_id': 'terminate_virtual_private_gateway',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.unregister_gate_peer_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/gate/peers/{outer_ip_address}',
                'operation_id': 'unregister_gate_peer',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'outer_ip_address',
                ],
                'required': [
                    'vpg_id',
                    'outer_ip_address',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'outer_ip_address':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'outer_ip_address': 'outer_ip_address',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'outer_ip_address': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.unset_inspection_configuration_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/junction/unset_inspection',
                'operation_id': 'unset_inspection_configuration',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.unset_redirection_configuration_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/junction/unset_redirection',
                'operation_id': 'unset_redirection_configuration',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                ],
                'required': [
                    'vpg_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                },
                'location_map': {
                    'vpg_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.update_mirroring_peer_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/virtual_private_gateways/{vpg_id}/junction/mirroring/peers/{ipaddr}',
                'operation_id': 'update_mirroring_peer',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'vpg_id',
                    'ipaddr',
                    'attribute_update',
                ],
                'required': [
                    'vpg_id',
                    'ipaddr',
                    'attribute_update',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'vpg_id':
                        (str,),
                    'ipaddr':
                        (str,),
                    'attribute_update':
                        ([AttributeUpdate],),
                },
                'attribute_map': {
                    'vpg_id': 'vpg_id',
                    'ipaddr': 'ipaddr',
                },
                'location_map': {
                    'vpg_id': 'path',
                    'ipaddr': 'path',
                    'attribute_update': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def close_gate(
        self,
        vpg_id,
        **kwargs
    ):
        """Close SORACOM Gate.  # noqa: E501

        Close SORACOM Gate on the specified VPG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.close_gate(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.close_gate_endpoint.call_with_http_info(**kwargs)

    def create_mirroring_peer(
        self,
        vpg_id,
        junction_mirroring_peer,
        **kwargs
    ):
        """Add node in the list of Junction mirroring peers  # noqa: E501

        Add node in the list of Junction mirroring peers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_mirroring_peer(vpg_id, junction_mirroring_peer, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            junction_mirroring_peer (JunctionMirroringPeer): Mirroring peer

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['junction_mirroring_peer'] = \
            junction_mirroring_peer
        return self.create_mirroring_peer_endpoint.call_with_http_info(**kwargs)

    def create_packet_capture_session(
        self,
        vpg_id,
        packet_capture_session_request,
        **kwargs
    ):
        """Create Packet Capture Session  # noqa: E501

        Create a packet capture sessions associated the VPG  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_packet_capture_session(vpg_id, packet_capture_session_request, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            packet_capture_session_request (PacketCaptureSessionRequest): A packet capture session request

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PacketCaptureSession
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['packet_capture_session_request'] = \
            packet_capture_session_request
        return self.create_packet_capture_session_endpoint.call_with_http_info(**kwargs)

    def create_virtual_private_gateway(
        self,
        create_virtual_private_gateway_request,
        **kwargs
    ):
        """Create Virtual Private Gateway.  # noqa: E501

        Create new VPG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_virtual_private_gateway(create_virtual_private_gateway_request, async_req=True)
        >>> result = thread.get()

        Args:
            create_virtual_private_gateway_request (CreateVirtualPrivateGatewayRequest): Request containing information for the new VPG to be created.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            VirtualPrivateGateway
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['create_virtual_private_gateway_request'] = \
            create_virtual_private_gateway_request
        return self.create_virtual_private_gateway_endpoint.call_with_http_info(**kwargs)

    def create_vpc_peering_connection(
        self,
        vpg_id,
        create_vpc_peering_connection_request,
        **kwargs
    ):
        """Create VPC Peering Connection  # noqa: E501

        Creates a VPC peering connection for the specified VPG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_vpc_peering_connection(vpg_id, create_vpc_peering_connection_request, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.
            create_vpc_peering_connection_request (CreateVpcPeeringConnectionRequest): VPC peering connection to be created.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            CreateVpcPeeringConnectionRequest
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['create_vpc_peering_connection_request'] = \
            create_vpc_peering_connection_request
        return self.create_vpc_peering_connection_endpoint.call_with_http_info(**kwargs)

    def delete_mirroring_peer(
        self,
        vpg_id,
        ipaddr,
        **kwargs
    ):
        """Remove peer from the list of Junction mirroring peers  # noqa: E501

        Remove peer from the list of Junction mirroring peers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_mirroring_peer(vpg_id, ipaddr, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            ipaddr (str): IP address of mirroring peer

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['ipaddr'] = \
            ipaddr
        return self.delete_mirroring_peer_endpoint.call_with_http_info(**kwargs)

    def delete_packet_capture_session(
        self,
        vpg_id,
        session_id,
        **kwargs
    ):
        """Delete Packet Capture Session  # noqa: E501

        Delete a packet capture sessions associated the VPG  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_packet_capture_session(vpg_id, session_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            session_id (str): Packet capture session ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PacketCaptureSession
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['session_id'] = \
            session_id
        return self.delete_packet_capture_session_endpoint.call_with_http_info(**kwargs)

    def delete_virtual_private_gateway_ip_address_map_entry(
        self,
        vpg_id,
        key,
        **kwargs
    ):
        """Delete VPG IP address map entry  # noqa: E501

        Deletes an entry in VPG IP address map.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_virtual_private_gateway_ip_address_map_entry(vpg_id, key, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.
            key (str): Target key to remove.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpAddressMapEntry
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['key'] = \
            key
        return self.delete_virtual_private_gateway_ip_address_map_entry_endpoint.call_with_http_info(**kwargs)

    def delete_vpc_peering_connection(
        self,
        vpg_id,
        pcx_id,
        **kwargs
    ):
        """Delete VPC Peering Connection.  # noqa: E501

        Deletes the specified VPC peering connection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_vpc_peering_connection(vpg_id, pcx_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.
            pcx_id (str): VPC peering connection ID to be deleted.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['pcx_id'] = \
            pcx_id
        return self.delete_vpc_peering_connection_endpoint.call_with_http_info(**kwargs)

    def get_packet_capture_session(
        self,
        vpg_id,
        session_id,
        **kwargs
    ):
        """Get Packet Capture Session  # noqa: E501

        Get a packet capture sessions associated the VPG  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_packet_capture_session(vpg_id, session_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            session_id (str): Packet capture session ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PacketCaptureSession
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['session_id'] = \
            session_id
        return self.get_packet_capture_session_endpoint.call_with_http_info(**kwargs)

    def get_virtual_private_gateway(
        self,
        vpg_id,
        **kwargs
    ):
        """Get Virtual Private Gateway.  # noqa: E501

        Retrieves information about the specified VPG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_virtual_private_gateway(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.get_virtual_private_gateway_endpoint.call_with_http_info(**kwargs)

    def list_gate_peers(
        self,
        vpg_id,
        **kwargs
    ):
        """List VPG Gate peers  # noqa: E501

        List Gate peers registered in the Virtual Private Gateway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_gate_peers(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [GatePeer]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.list_gate_peers_endpoint.call_with_http_info(**kwargs)

    def list_packet_capture_sessions(
        self,
        vpg_id,
        **kwargs
    ):
        """List Packet Capture Sessions  # noqa: E501

        List packet capture sessions associated with the VPG  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_packet_capture_sessions(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID

        Keyword Args:
            last_evaluated_key (str): ID of the last group in the previous page. [optional] if omitted the server will use the default value of "null"
            limit (int): Max number of results in a response. [optional] if omitted the server will use the default value of 10
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [PacketCaptureSession]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.list_packet_capture_sessions_endpoint.call_with_http_info(**kwargs)

    def list_virtual_private_gateway_ip_address_map_entries(
        self,
        vpg_id,
        **kwargs
    ):
        """List VPG IP address map entries  # noqa: E501

        Describes the list of IP address map entries in the Virtual Private Gateway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_virtual_private_gateway_ip_address_map_entries(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [IpAddressMapEntry]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.list_virtual_private_gateway_ip_address_map_entries_endpoint.call_with_http_info(**kwargs)

    def list_virtual_private_gateways(
        self,
        **kwargs
    ):
        """List Virtual Private Gateways.  # noqa: E501

        Returns a list of VPGs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_virtual_private_gateways(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            tag_name (str): Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.. [optional]
            tag_value (str): Tag value of the VPGs.. [optional]
            tag_value_match_mode (str): Tag match mode.. [optional] if omitted the server will use the default value of "exact"
            limit (int): Maximum number of results per response page.. [optional]
            last_evaluated_key (str): The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [VirtualPrivateGateway]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.list_virtual_private_gateways_endpoint.call_with_http_info(**kwargs)

    def open_gate(
        self,
        vpg_id,
        **kwargs
    ):
        """Open SORACOM Gate.  # noqa: E501

        Open SORACOM Gate on the specified VPG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.open_gate(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.

        Keyword Args:
            open_gate_request (OpenGateRequest): Optional configuration parameters for Gate.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.open_gate_endpoint.call_with_http_info(**kwargs)

    def put_virtual_private_gateway_ip_address_map_entry(
        self,
        vpg_id,
        put_ip_address_map_entry_request,
        **kwargs
    ):
        """Put an entry in VPG IP address map  # noqa: E501

        Puts an entry in VPG IP address map.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_virtual_private_gateway_ip_address_map_entry(vpg_id, put_ip_address_map_entry_request, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.
            put_ip_address_map_entry_request (PutIpAddressMapEntryRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpAddressMapEntry
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['put_ip_address_map_entry_request'] = \
            put_ip_address_map_entry_request
        return self.put_virtual_private_gateway_ip_address_map_entry_endpoint.call_with_http_info(**kwargs)

    def register_gate_peer(
        self,
        vpg_id,
        register_gate_peer_request,
        **kwargs
    ):
        """Register VPG Gate peer  # noqa: E501

        Register a host as a gate peer in the Virtual Private Gateway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_gate_peer(vpg_id, register_gate_peer_request, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.
            register_gate_peer_request (RegisterGatePeerRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            GatePeer
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['register_gate_peer_request'] = \
            register_gate_peer_request
        return self.register_gate_peer_endpoint.call_with_http_info(**kwargs)

    def set_inspection_configuration(
        self,
        vpg_id,
        junction_inspection_configuration,
        **kwargs
    ):
        """Set configuration for Junction inspection feature  # noqa: E501

        Set configuration for Junction inspection feature  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_inspection_configuration(vpg_id, junction_inspection_configuration, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            junction_inspection_configuration (JunctionInspectionConfiguration): Inspection configuration

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['junction_inspection_configuration'] = \
            junction_inspection_configuration
        return self.set_inspection_configuration_endpoint.call_with_http_info(**kwargs)

    def set_redirection_configuration(
        self,
        vpg_id,
        junction_redirection_configuration,
        **kwargs
    ):
        """Set configuration for Junction redirection feature  # noqa: E501

        Set configuration for Junction redirection feature  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_redirection_configuration(vpg_id, junction_redirection_configuration, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            junction_redirection_configuration (JunctionRedirectionConfiguration): Redirection configuration

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['junction_redirection_configuration'] = \
            junction_redirection_configuration
        return self.set_redirection_configuration_endpoint.call_with_http_info(**kwargs)

    def set_routing_filter(
        self,
        vpg_id,
        routing_filter_entry,
        **kwargs
    ):
        """Sets Virtual Private Gateway outbound routing filter.  # noqa: E501

        Sets Virtual Private Gateway outbound routing filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_routing_filter(vpg_id, routing_filter_entry, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.
            routing_filter_entry ([RoutingFilterEntry]): List of routing filter entries

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['routing_filter_entry'] = \
            routing_filter_entry
        return self.set_routing_filter_endpoint.call_with_http_info(**kwargs)

    def stop_packet_capture_session(
        self,
        vpg_id,
        session_id,
        **kwargs
    ):
        """Stop Packet Capture Session  # noqa: E501

        Stop a packet capture session associated with the VPG  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stop_packet_capture_session(vpg_id, session_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            session_id (str): Packet capture session ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PacketCaptureSession
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['session_id'] = \
            session_id
        return self.stop_packet_capture_session_endpoint.call_with_http_info(**kwargs)

    def terminate_virtual_private_gateway(
        self,
        vpg_id,
        **kwargs
    ):
        """Terminate Virtual Private Gateway.  # noqa: E501

        Terminates the specified VPG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.terminate_virtual_private_gateway(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.terminate_virtual_private_gateway_endpoint.call_with_http_info(**kwargs)

    def unregister_gate_peer(
        self,
        vpg_id,
        outer_ip_address,
        **kwargs
    ):
        """Unregister VPG gate peer  # noqa: E501

        Unregister a gate peer from the Virtual Private Gateway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unregister_gate_peer(vpg_id, outer_ip_address, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): Target VPG ID.
            outer_ip_address (str): ID of the target node.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['outer_ip_address'] = \
            outer_ip_address
        return self.unregister_gate_peer_endpoint.call_with_http_info(**kwargs)

    def unset_inspection_configuration(
        self,
        vpg_id,
        **kwargs
    ):
        """Unset configuration for Junction inspection feature  # noqa: E501

        Unset configuration for Junction inspection feature  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unset_inspection_configuration(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.unset_inspection_configuration_endpoint.call_with_http_info(**kwargs)

    def unset_redirection_configuration(
        self,
        vpg_id,
        **kwargs
    ):
        """Unset configuration for Junction redirection feature  # noqa: E501

        Unset configuration for Junction redirection feature  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unset_redirection_configuration(vpg_id, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        return self.unset_redirection_configuration_endpoint.call_with_http_info(**kwargs)

    def update_mirroring_peer(
        self,
        vpg_id,
        ipaddr,
        attribute_update,
        **kwargs
    ):
        """Update a Junction mirroring peer  # noqa: E501

        Update a Junction mirroring peer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_mirroring_peer(vpg_id, ipaddr, attribute_update, async_req=True)
        >>> result = thread.get()

        Args:
            vpg_id (str): VPG ID
            ipaddr (str): Mirroring peer IP address
            attribute_update ([AttributeUpdate]): List of attributes to update

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['vpg_id'] = \
            vpg_id
        kwargs['ipaddr'] = \
            ipaddr
        kwargs['attribute_update'] = \
            attribute_update
        return self.update_mirroring_peer_endpoint.call_with_http_info(**kwargs)

