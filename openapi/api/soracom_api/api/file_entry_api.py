"""
    SORACOM API

    SORACOM API v1  # noqa: E501

    The version of the OpenAPI document: VERSION_PLACEHOLDER
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from soracom_api.api_client import ApiClient, Endpoint as _Endpoint
from soracom_api.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from soracom_api.model.file_entry import FileEntry


class FileEntryApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.delete_directory_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/files/{scope}/{path}/',
                'operation_id': 'delete_directory',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'scope',
                    'path',
                ],
                'required': [
                    'scope',
                    'path',
                ],
                'nullable': [
                ],
                'enum': [
                    'scope',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('scope',): {

                        "PRIVATE": "private"
                    },
                },
                'openapi_types': {
                    'scope':
                        (str,),
                    'path':
                        (str,),
                },
                'attribute_map': {
                    'scope': 'scope',
                    'path': 'path',
                },
                'location_map': {
                    'scope': 'path',
                    'path': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_file_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/files/{scope}/{path}',
                'operation_id': 'delete_file',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'scope',
                    'path',
                ],
                'required': [
                    'scope',
                    'path',
                ],
                'nullable': [
                ],
                'enum': [
                    'scope',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('scope',): {

                        "PRIVATE": "private"
                    },
                },
                'openapi_types': {
                    'scope':
                        (str,),
                    'path':
                        (str,),
                },
                'attribute_map': {
                    'scope': 'scope',
                    'path': 'path',
                },
                'location_map': {
                    'scope': 'path',
                    'path': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.find_files_endpoint = _Endpoint(
            settings={
                'response_type': ([FileEntry],),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/files',
                'operation_id': 'find_files',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'scope',
                    'prefix',
                    'limit',
                    'last_evaluated_key',
                ],
                'required': [
                    'scope',
                    'prefix',
                ],
                'nullable': [
                ],
                'enum': [
                    'scope',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('scope',): {

                        "PRIVATE": "private",
                        "PUBLIC": "public"
                    },
                },
                'openapi_types': {
                    'scope':
                        (str,),
                    'prefix':
                        (str,),
                    'limit':
                        (str,),
                    'last_evaluated_key':
                        (str,),
                },
                'attribute_map': {
                    'scope': 'scope',
                    'prefix': 'prefix',
                    'limit': 'limit',
                    'last_evaluated_key': 'last_evaluated_key',
                },
                'location_map': {
                    'scope': 'query',
                    'prefix': 'query',
                    'limit': 'query',
                    'last_evaluated_key': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;charset=UTF-8'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_file_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/files/{scope}/{path}',
                'operation_id': 'get_file',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'scope',
                    'path',
                ],
                'required': [
                    'scope',
                    'path',
                ],
                'nullable': [
                ],
                'enum': [
                    'scope',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('scope',): {

                        "PRIVATE": "private",
                        "PUBLIC": "public"
                    },
                },
                'openapi_types': {
                    'scope':
                        (str,),
                    'path':
                        (str,),
                },
                'attribute_map': {
                    'scope': 'scope',
                    'path': 'path',
                },
                'location_map': {
                    'scope': 'path',
                    'path': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_file_metadata_endpoint = _Endpoint(
            settings={
                'response_type': (FileEntry,),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/files/{scope}/{path}',
                'operation_id': 'get_file_metadata',
                'http_method': 'HEAD',
                'servers': None,
            },
            params_map={
                'all': [
                    'scope',
                    'path',
                ],
                'required': [
                    'scope',
                    'path',
                ],
                'nullable': [
                ],
                'enum': [
                    'scope',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('scope',): {

                        "PRIVATE": "private",
                        "PUBLIC": "public"
                    },
                },
                'openapi_types': {
                    'scope':
                        (str,),
                    'path':
                        (str,),
                },
                'attribute_map': {
                    'scope': 'scope',
                    'path': 'path',
                },
                'location_map': {
                    'scope': 'path',
                    'path': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_files_endpoint = _Endpoint(
            settings={
                'response_type': ([FileEntry],),
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/files/{scope}/{path}/',
                'operation_id': 'list_files',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'scope',
                    'path',
                    'limit',
                    'last_evaluated_key',
                ],
                'required': [
                    'scope',
                    'path',
                ],
                'nullable': [
                ],
                'enum': [
                    'scope',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('scope',): {

                        "PRIVATE": "private",
                        "PUBLIC": "public"
                    },
                },
                'openapi_types': {
                    'scope':
                        (str,),
                    'path':
                        (str,),
                    'limit':
                        (str,),
                    'last_evaluated_key':
                        (str,),
                },
                'attribute_map': {
                    'scope': 'scope',
                    'path': 'path',
                    'limit': 'limit',
                    'last_evaluated_key': 'last_evaluated_key',
                },
                'location_map': {
                    'scope': 'path',
                    'path': 'path',
                    'limit': 'query',
                    'last_evaluated_key': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.put_file_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'api_key',
                    'api_token'
                ],
                'endpoint_path': '/files/{scope}/{path}',
                'operation_id': 'put_file',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'scope',
                    'path',
                    'body',
                    'content_type',
                ],
                'required': [
                    'scope',
                    'path',
                    'body',
                ],
                'nullable': [
                ],
                'enum': [
                    'scope',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('scope',): {

                        "PRIVATE": "private"
                    },
                },
                'openapi_types': {
                    'scope':
                        (str,),
                    'path':
                        (str,),
                    'body':
                        (file_type,),
                    'content_type':
                        (str,),
                },
                'attribute_map': {
                    'scope': 'scope',
                    'path': 'path',
                    'content_type': 'content-type',
                },
                'location_map': {
                    'scope': 'path',
                    'path': 'path',
                    'body': 'body',
                    'content_type': 'header',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )

    def delete_directory(
        self,
        path,
        scope="private",
        **kwargs
    ):
        """Delete specified directory in the scope.  # noqa: E501

        Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_directory(path, scope="private", async_req=True)
        >>> result = thread.get()

        Args:
            path (str): Target directory path
            scope (str): Scope of the request. defaults to "private", must be one of ["private"]

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['scope'] = \
            scope
        kwargs['path'] = \
            path
        return self.delete_directory_endpoint.call_with_http_info(**kwargs)

    def delete_file(
        self,
        path,
        scope="private",
        **kwargs
    ):
        """Delete specified file in the scope.  # noqa: E501

        Deletes the specified file in the scope. Only `private` scope is allowed for the operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_file(path, scope="private", async_req=True)
        >>> result = thread.get()

        Args:
            path (str): Target path
            scope (str): Scope of the request. defaults to "private", must be one of ["private"]

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['scope'] = \
            scope
        kwargs['path'] = \
            path
        return self.delete_file_endpoint.call_with_http_info(**kwargs)

    def find_files(
        self,
        scope,
        prefix,
        **kwargs
    ):
        """Find files with prefix query parameter in the scope  # noqa: E501

        Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_files(scope, prefix, async_req=True)
        >>> result = thread.get()

        Args:
            scope (str): Scope of the request
            prefix (str): Prefix to match with file path

        Keyword Args:
            limit (str): Num of entries. [optional] if omitted the server will use the default value of "10"
            last_evaluated_key (str): The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [FileEntry]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['scope'] = \
            scope
        kwargs['prefix'] = \
            prefix
        return self.find_files_endpoint.call_with_http_info(**kwargs)

    def get_file(
        self,
        path,
        scope="private",
        **kwargs
    ):
        """Download file specified by the path and the scope  # noqa: E501

        Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_file(path, scope="private", async_req=True)
        >>> result = thread.get()

        Args:
            path (str): Target path
            scope (str): Scope of the request. defaults to "private", must be one of ["private"]

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['scope'] = \
            scope
        kwargs['path'] = \
            path
        return self.get_file_endpoint.call_with_http_info(**kwargs)

    def get_file_metadata(
        self,
        path,
        scope="private",
        **kwargs
    ):
        """Get the metadata of the file specified by the path and the scope  # noqa: E501

        Gets metadata of the file specified by the path and the scope.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_file_metadata(path, scope="private", async_req=True)
        >>> result = thread.get()

        Args:
            path (str): Target path
            scope (str): Scope of the request. defaults to "private", must be one of ["private"]

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            FileEntry
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['scope'] = \
            scope
        kwargs['path'] = \
            path
        return self.get_file_metadata_endpoint.call_with_http_info(**kwargs)

    def list_files(
        self,
        scope="private",
        path="/",
        **kwargs
    ):
        """List files and directories on the path in the scope  # noqa: E501

        Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the 'Link' header of the response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_files(scope="private", path="/", async_req=True)
        >>> result = thread.get()

        Args:
            scope (str): Scope of the request. defaults to "private", must be one of ["private"]
            path (str): Target path. defaults to "/", must be one of ["/"]

        Keyword Args:
            limit (str): Num of entries. [optional] if omitted the server will use the default value of "10"
            last_evaluated_key (str): The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [FileEntry]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['scope'] = \
            scope
        kwargs['path'] = \
            path
        return self.list_files_endpoint.call_with_http_info(**kwargs)

    def put_file(
        self,
        path,
        body,
        scope="private",
        **kwargs
    ):
        """Upload file to the path in the scope.  # noqa: E501

        Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_file(path, body, scope="private", async_req=True)
        >>> result = thread.get()

        Args:
            path (str): Target path
            body (file_type): Content of the file to upload
            scope (str): Scope of the request. defaults to "private", must be one of ["private"]

        Keyword Args:
            content_type (str): Content type of the file to upload. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['scope'] = \
            scope
        kwargs['path'] = \
            path
        kwargs['body'] = \
            body
        return self.put_file_endpoint.call_with_http_info(**kwargs)

